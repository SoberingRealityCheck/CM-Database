{
  "created": 1722029015.8255773,
  "duration": 7.354585647583008,
  "exitcode": 1,
  "root": "/home/jsw/mezz/econd-sw/test_mezzanine",
  "environment": {},
  "summary": {
    "failed": 12,
    "passed": 6,
    "total": 18,
    "collected": 18
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test_i2c.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "test_i2c.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test_i2c.py::test_rw_allregisters_D[0]",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "test_i2c.py::test_rw_allregisters_D[255]",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "test_i2c.py::test_rw_allregisters_T[0]",
          "type": "Function",
          "lineno": 58
        },
        {
          "nodeid": "test_i2c.py::test_rw_allregisters_T[255]",
          "type": "Function",
          "lineno": 58
        },
        {
          "nodeid": "test_i2c.py::test_hard_reset_i2c_allregisters_D",
          "type": "Function",
          "lineno": 84
        },
        {
          "nodeid": "test_i2c.py::test_hard_reset_i2c_allregisters_T",
          "type": "Function",
          "lineno": 107
        },
        {
          "nodeid": "test_i2c.py::test_soft_reset_i2c_allregisters_D",
          "type": "Function",
          "lineno": 130
        },
        {
          "nodeid": "test_i2c.py::test_soft_reset_i2c_allregisters_T",
          "type": "Function",
          "lineno": 153
        },
        {
          "nodeid": "test_i2c.py::test_wrong_reg_address_D",
          "type": "Function",
          "lineno": 176
        },
        {
          "nodeid": "test_i2c.py::test_wrong_reg_address_T",
          "type": "Function",
          "lineno": 200
        },
        {
          "nodeid": "test_i2c.py::test_wrong_i2c_address_D",
          "type": "Function",
          "lineno": 224
        },
        {
          "nodeid": "test_i2c.py::test_wrong_i2c_address_T",
          "type": "Function",
          "lineno": 237
        },
        {
          "nodeid": "test_i2c.py::test_hold_hard_reset_D",
          "type": "Function",
          "lineno": 250
        },
        {
          "nodeid": "test_i2c.py::test_hold_hard_reset_T",
          "type": "Function",
          "lineno": 264
        },
        {
          "nodeid": "test_i2c.py::test_hold_soft_reset_D",
          "type": "Function",
          "lineno": 278
        },
        {
          "nodeid": "test_i2c.py::test_hold_soft_reset_T",
          "type": "Function",
          "lineno": 299
        },
        {
          "nodeid": "test_i2c.py::test_chip_sync_D",
          "type": "Function",
          "lineno": 320
        },
        {
          "nodeid": "test_i2c.py::test_chip_sync_T",
          "type": "Function",
          "lineno": 341
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "test_i2c.py::test_rw_allregisters_D[0]",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_rw_allregisters_D[0]",
        "pytestmark",
        "0",
        "parametrize",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.5060580090030271,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0026543100029812194,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 279.\nFailed on attempt 1 at write 0 of 279.\nFailed on attempt 2 at write 0 of 279.\n",
        "longrepr": "to_write = 0, i2c_ECOND = <econ_i2c.ECON_I2C object at 0xffff8a2c06a0>, CfgConverterD = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8b328d30>, out_of_reset = None\n\n    @pytest.mark.ECOND\n    @pytest.mark.parametrize(\"to_write\", [0, 0xFF])\n    def test_rw_allregisters_D(\n        to_write, i2c_ECOND, CfgConverterD, out_of_reset,\n    ):\n        \"\"\"\n        Test all read/write I2C registers by writing to all of them, then reading\n        them back and comparing.\n    \n        First write all zeros and compare, then write all ones and compare.\n        \"\"\"\n        write_array = to_write * numpy.ones(\n            CfgConverterD.total_length_bytes, dtype=numpy.uint8\n        )\n    \n>       i2c_ECOND.write_all(CfgConverterD.RW_mask_array & write_array)\n\ntest_i2c.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2c0760>, i2c_msgs = (i2c_msg(96,0,b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff8b3197c0>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0015315939999709371,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_rw_allregisters_D[255]",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_rw_allregisters_D[255]",
        "pytestmark",
        "255",
        "parametrize",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.003830904999631457,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0022214300006453414,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 279.\nFailed on attempt 1 at write 0 of 279.\nFailed on attempt 2 at write 0 of 279.\n",
        "longrepr": "to_write = 255, i2c_ECOND = <econ_i2c.ECON_I2C object at 0xffff8a2c06a0>, CfgConverterD = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8b328d30>, out_of_reset = None\n\n    @pytest.mark.ECOND\n    @pytest.mark.parametrize(\"to_write\", [0, 0xFF])\n    def test_rw_allregisters_D(\n        to_write, i2c_ECOND, CfgConverterD, out_of_reset,\n    ):\n        \"\"\"\n        Test all read/write I2C registers by writing to all of them, then reading\n        them back and comparing.\n    \n        First write all zeros and compare, then write all ones and compare.\n        \"\"\"\n        write_array = to_write * numpy.ones(\n            CfgConverterD.total_length_bytes, dtype=numpy.uint8\n        )\n    \n>       i2c_ECOND.write_all(CfgConverterD.RW_mask_array & write_array)\n\ntest_i2c.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2c0760>, i2c_msgs = (i2c_msg(96,0,b'\\x00\\x00\\x7f\\xff\\xff?\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff8a02a840>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0014841030024399515,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_rw_allregisters_T[0]",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_rw_allregisters_T[0]",
        "pytestmark",
        "0",
        "parametrize",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.12671463699734886,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.002933074996690266,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 76,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 228.\nFailed on attempt 1 at write 0 of 228.\nFailed on attempt 2 at write 0 of 228.\n",
        "longrepr": "to_write = 0, i2c_ECONT = <econ_i2c.ECON_I2C object at 0xffff8a2b2a90>, CfgConverterT = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8a267280>, out_of_reset = None\nsupport_ECONT = <utils.support.Support object at 0xffff8a2c0a90>\n\n    @pytest.mark.ECONT\n    @pytest.mark.parametrize(\"to_write\", [0, 0xFF])\n    def test_rw_allregisters_T(\n        to_write, i2c_ECONT, CfgConverterT, out_of_reset, support_ECONT,\n    ):\n        \"\"\"\n        Test all read/write I2C registers by writing to all of them, then reading\n        them back and comparing.\n    \n        First write all zeros and compare, then write all ones and compare.\n        \"\"\"\n        support_ECONT.reset(3)\n        support_ECONT.out_of_reset()\n        write_array = to_write * numpy.ones(\n            CfgConverterT.total_length_bytes, dtype=numpy.uint8\n        )\n    \n>       i2c_ECONT.write_all(CfgConverterT.RW_mask_array & write_array)\n\ntest_i2c.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2b2850>, i2c_msgs = (i2c_msg(32,0,b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff8a02ad40>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0014691920005134307,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_rw_allregisters_T[255]",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_rw_allregisters_T[255]",
        "pytestmark",
        "255",
        "parametrize",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.0038222049988689832,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0028518940016510896,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 76,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 228.\nFailed on attempt 1 at write 0 of 228.\nFailed on attempt 2 at write 0 of 228.\n",
        "longrepr": "to_write = 255, i2c_ECONT = <econ_i2c.ECON_I2C object at 0xffff8a2b2a90>, CfgConverterT = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8a267280>, out_of_reset = None\nsupport_ECONT = <utils.support.Support object at 0xffff8a2c0a90>\n\n    @pytest.mark.ECONT\n    @pytest.mark.parametrize(\"to_write\", [0, 0xFF])\n    def test_rw_allregisters_T(\n        to_write, i2c_ECONT, CfgConverterT, out_of_reset, support_ECONT,\n    ):\n        \"\"\"\n        Test all read/write I2C registers by writing to all of them, then reading\n        them back and comparing.\n    \n        First write all zeros and compare, then write all ones and compare.\n        \"\"\"\n        support_ECONT.reset(3)\n        support_ECONT.out_of_reset()\n        write_array = to_write * numpy.ones(\n            CfgConverterT.total_length_bytes, dtype=numpy.uint8\n        )\n    \n>       i2c_ECONT.write_all(CfgConverterT.RW_mask_array & write_array)\n\ntest_i2c.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2b2850>, i2c_msgs = (i2c_msg(32,0,b'\\x00\\x00\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff8a02aec0>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0014634630024374928,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_hard_reset_i2c_allregisters_D",
      "lineno": 84,
      "outcome": "failed",
      "keywords": [
        "test_hard_reset_i2c_allregisters_D",
        "pytestmark",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.0033466349996160716,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0020754769975610543,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 94,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 279.\nFailed on attempt 1 at write 0 of 279.\nFailed on attempt 2 at write 0 of 279.\n",
        "longrepr": "support_ECOND = <utils.support.Support object at 0xffff8a2c09a0>, i2c_ECOND = <econ_i2c.ECON_I2C object at 0xffff8a2c06a0>\nCfgConverterD = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8b328d30>, out_of_reset = None\n\n    @pytest.mark.ECOND\n    def test_hard_reset_i2c_allregisters_D(\n        support_ECOND, i2c_ECOND, CfgConverterD, out_of_reset,\n    ):\n        \"\"\"\n        Set all the RW I2C registers to non-default values, then do a hard reset,\n        and read all the I2C registers to see that they return to their default\n        values.\n        \"\"\"\n>       i2c_ECOND.write_all(\n            CfgConverterD.RW_mask_array & (~CfgConverterD.default_value_array)\n        )\n\ntest_i2c.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2c0760>, i2c_msgs = (i2c_msg(96,0,b'\\x00\\x00~\\xff\\xff?\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff89e97040>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.001403821002895711,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_hard_reset_i2c_allregisters_T",
      "lineno": 107,
      "outcome": "failed",
      "keywords": [
        "test_hard_reset_i2c_allregisters_T",
        "pytestmark",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.003398895998543594,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0021693779999623075,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 117,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 228.\nFailed on attempt 1 at write 0 of 228.\nFailed on attempt 2 at write 0 of 228.\n",
        "longrepr": "support_ECONT = <utils.support.Support object at 0xffff8a2c0a90>, i2c_ECONT = <econ_i2c.ECON_I2C object at 0xffff8a2b2a90>\nCfgConverterT = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8a267280>, out_of_reset = None\n\n    @pytest.mark.ECONT\n    def test_hard_reset_i2c_allregisters_T(\n        support_ECONT, i2c_ECONT, CfgConverterT, out_of_reset,\n    ):\n        \"\"\"\n        Set all the RW I2C registers to non-default values, then do a hard reset,\n        and read all the I2C registers to see that they return to their default\n        values.\n        \"\"\"\n>       i2c_ECONT.write_all(\n            CfgConverterT.RW_mask_array & (~CfgConverterT.default_value_array)\n        )\n\ntest_i2c.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2b2850>, i2c_msgs = (i2c_msg(32,0,b'\\x00\\x00~\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff89fbb140>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0013772710008197464,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_soft_reset_i2c_allregisters_D",
      "lineno": 130,
      "outcome": "failed",
      "keywords": [
        "test_soft_reset_i2c_allregisters_D",
        "pytestmark",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.00338584500059369,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0020912559994030744,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 140,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 279.\nFailed on attempt 1 at write 0 of 279.\nFailed on attempt 2 at write 0 of 279.\n",
        "longrepr": "support_ECOND = <utils.support.Support object at 0xffff8a2c09a0>, i2c_ECOND = <econ_i2c.ECON_I2C object at 0xffff8a2c06a0>\nCfgConverterD = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8b328d30>, out_of_reset = None\n\n    @pytest.mark.ECOND\n    def test_soft_reset_i2c_allregisters_D(\n        support_ECOND, i2c_ECOND, CfgConverterD, out_of_reset,\n    ):\n        \"\"\"\n        Set all the ECON-D RW I2C registers to non-default values, then do a soft\n        reset, and read all the I2C registers to see that they keep their\n        non-default values.\n        \"\"\"\n>       i2c_ECOND.write_all(\n            CfgConverterD.RW_mask_array & (~CfgConverterD.default_value_array)\n        )\n\ntest_i2c.py:140: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2c0760>, i2c_msgs = (i2c_msg(96,0,b'\\x00\\x00~\\xff\\xff?\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff89fbbec0>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0013976709997223224,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_soft_reset_i2c_allregisters_T",
      "lineno": 153,
      "outcome": "failed",
      "keywords": [
        "test_soft_reset_i2c_allregisters_T",
        "pytestmark",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.003350324997882126,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.002170158000808442,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 163,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 228.\nFailed on attempt 1 at write 0 of 228.\nFailed on attempt 2 at write 0 of 228.\n",
        "longrepr": "support_ECONT = <utils.support.Support object at 0xffff8a2c0a90>, i2c_ECONT = <econ_i2c.ECON_I2C object at 0xffff8a2b2a90>\nCfgConverterT = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8a267280>, out_of_reset = None\n\n    @pytest.mark.ECONT\n    def test_soft_reset_i2c_allregisters_T(\n        support_ECONT, i2c_ECONT, CfgConverterT, out_of_reset,\n    ):\n        \"\"\"\n        Set all the ECON-T RW I2C registers to non-default values, then do a soft\n        reset, and read all the I2C registers to see that they keep their\n        non-default values.\n        \"\"\"\n>       i2c_ECONT.write_all(\n            CfgConverterT.RW_mask_array & (~CfgConverterT.default_value_array)\n        )\n\ntest_i2c.py:163: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2b2850>, i2c_msgs = (i2c_msg(32,0,b'\\x00\\x00~\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff89fbb240>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0013849510032741819,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_wrong_reg_address_D",
      "lineno": 176,
      "outcome": "failed",
      "keywords": [
        "test_wrong_reg_address_D",
        "pytestmark",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.0033496940013719723,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0027602709997154307,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py",
          "lineno": 131,
          "message": "OSError: 5"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 191,
            "message": ""
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 131,
            "message": "OSError"
          }
        ],
        "log": [
          {
            "name": "Xil_i2c_bus_2",
            "msg": "Error occurred during read: ",
            "args": null,
            "levelname": "ERROR",
            "levelno": 40,
            "pathname": "/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py",
            "filename": "hexactrl_io.py",
            "module": "hexactrl_io",
            "exc_info": null,
            "exc_text": "Traceback (most recent call last):\n  File \"/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py\", line 125, in read\n    self.bus.i2c_rdwr(read)\n  File \"/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py\", line 658, in i2c_rdwr\n    ioctl(self.fd, I2C_RDWR, ioctl_data)\nOSError: [Errno 5] Input/output error",
            "stack_info": null,
            "lineno": 128,
            "funcName": "read",
            "created": 1722029014.6041827,
            "msecs": 604.1827201843262,
            "relativeCreated": 8159.926176071167,
            "thread": 281473294524448,
            "threadName": "MainThread",
            "processName": "MainProcess",
            "process": 3843
          }
        ],
        "longrepr": "self = <econ_tools.swamp.hexactrl_io.Xil_i2c object at 0xffff8a2c0700>, address = 96, count = 16, log = True\n\n    def read(\n        self,\n        address: int,\n        count: int = 1,\n        log: bool = True,\n    ):\n        \"\"\"\n        Read data from the i2c address specified\n    \n        :param address: The address of the peripheral on the bus to read data\n            from, must be 0-127\n        :type address: byte\n        :param count: The number of bytes to read form the bus if the count is\n            larger than one a block read is performed. Defaults to 1.\n        :type count: int, optional\n        :return: Array of values read for the different bytes as list of ints\n        :rtype: list\n        \"\"\"\n        if count == 1:\n            if log:\n                self.transaction_logger.debug(\n                    f\"Reading SingleByte \" f\"from addr = {address}\"\n                )\n            try:\n                ret = self.bus.read_byte(address).to_bytes(1, \"little\")\n            except IOError as e:\n                self.transaction_logger.error(\n                    \"Error occurred during read: \", exc_info=True\n                )\n                raise IOError(e.args[0])\n            if log:\n                self.transaction_logger.debug(f\"Read returned {ret}\")\n        else:\n            if log:\n                self.transaction_logger.debug(\n                    f\"Reading {count} Bytes \" f\"from addr = {address}\"\n                )\n            try:\n                read = i2c_msg.read(address, count)\n>               self.bus.i2c_rdwr(read)\n\n../econ_tools/swamp/hexactrl_io.py:125: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2c0760>, i2c_msgs = (i2c_msg(96,1,b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff8a02ae40>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError\n\nDuring handling of the above exception, another exception occurred:\n\ni2c_ECOND = <econ_i2c.ECON_I2C object at 0xffff8a2c06a0>, CfgConverterD = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8b328d30>\nsupport_ECOND = <utils.support.Support object at 0xffff8a2c09a0>, out_of_reset = None\n\n    @pytest.mark.ECOND\n    def test_wrong_reg_address_D(\n        i2c_ECOND, CfgConverterD, support_ECOND, out_of_reset,\n    ):\n        \"\"\"\n        Check that we get zeros when reading from some internal address that\n        doesn't correspond to any I2C register.\n        \"\"\"\n        i2c_ECOND.target.transport.write(\n            address=i2c_ECOND.target.base_address,\n            data=None,\n            internal_address=(0xFFFF - 16).to_bytes(2, \"big\"),\n        )\n    \n>       read_bytes = i2c_ECOND.target.transport.read(\n            address=i2c_ECOND.target.base_address,\n            count=16,\n        )\n\ntest_i2c.py:191: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <econ_tools.swamp.hexactrl_io.Xil_i2c object at 0xffff8a2c0700>, address = 96, count = 16, log = True\n\n    def read(\n        self,\n        address: int,\n        count: int = 1,\n        log: bool = True,\n    ):\n        \"\"\"\n        Read data from the i2c address specified\n    \n        :param address: The address of the peripheral on the bus to read data\n            from, must be 0-127\n        :type address: byte\n        :param count: The number of bytes to read form the bus if the count is\n            larger than one a block read is performed. Defaults to 1.\n        :type count: int, optional\n        :return: Array of values read for the different bytes as list of ints\n        :rtype: list\n        \"\"\"\n        if count == 1:\n            if log:\n                self.transaction_logger.debug(\n                    f\"Reading SingleByte \" f\"from addr = {address}\"\n                )\n            try:\n                ret = self.bus.read_byte(address).to_bytes(1, \"little\")\n            except IOError as e:\n                self.transaction_logger.error(\n                    \"Error occurred during read: \", exc_info=True\n                )\n                raise IOError(e.args[0])\n            if log:\n                self.transaction_logger.debug(f\"Read returned {ret}\")\n        else:\n            if log:\n                self.transaction_logger.debug(\n                    f\"Reading {count} Bytes \" f\"from addr = {address}\"\n                )\n            try:\n                read = i2c_msg.read(address, count)\n                self.bus.i2c_rdwr(read)\n                ret = bytearray(list(read))\n            except IOError as e:\n                self.transaction_logger.error(\n                    \"Error occurred during read: \", exc_info=True\n                )\n>               raise IOError(e.args[0])\nE               OSError: 5\n\n../econ_tools/swamp/hexactrl_io.py:131: OSError"
      },
      "teardown": {
        "duration": 0.0013931109970144462,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_wrong_reg_address_T",
      "lineno": 200,
      "outcome": "failed",
      "keywords": [
        "test_wrong_reg_address_T",
        "pytestmark",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.0033966160008276347,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.002726971000811318,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py",
          "lineno": 131,
          "message": "OSError: 5"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 215,
            "message": ""
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 131,
            "message": "OSError"
          }
        ],
        "log": [
          {
            "name": "Xil_i2c_bus_2",
            "msg": "Error occurred during read: ",
            "args": null,
            "levelname": "ERROR",
            "levelno": 40,
            "pathname": "/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py",
            "filename": "hexactrl_io.py",
            "module": "hexactrl_io",
            "exc_info": null,
            "exc_text": "Traceback (most recent call last):\n  File \"/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py\", line 125, in read\n    self.bus.i2c_rdwr(read)\n  File \"/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py\", line 658, in i2c_rdwr\n    ioctl(self.fd, I2C_RDWR, ioctl_data)\nOSError: [Errno 5] Input/output error",
            "stack_info": null,
            "lineno": 128,
            "funcName": "read",
            "created": 1722029014.739369,
            "msecs": 739.3689155578613,
            "relativeCreated": 8295.112371444702,
            "thread": 281473294524448,
            "threadName": "MainThread",
            "processName": "MainProcess",
            "process": 3843
          }
        ],
        "longrepr": "self = <econ_tools.swamp.hexactrl_io.Xil_i2c object at 0xffff8a2b2a30>, address = 32, count = 16, log = True\n\n    def read(\n        self,\n        address: int,\n        count: int = 1,\n        log: bool = True,\n    ):\n        \"\"\"\n        Read data from the i2c address specified\n    \n        :param address: The address of the peripheral on the bus to read data\n            from, must be 0-127\n        :type address: byte\n        :param count: The number of bytes to read form the bus if the count is\n            larger than one a block read is performed. Defaults to 1.\n        :type count: int, optional\n        :return: Array of values read for the different bytes as list of ints\n        :rtype: list\n        \"\"\"\n        if count == 1:\n            if log:\n                self.transaction_logger.debug(\n                    f\"Reading SingleByte \" f\"from addr = {address}\"\n                )\n            try:\n                ret = self.bus.read_byte(address).to_bytes(1, \"little\")\n            except IOError as e:\n                self.transaction_logger.error(\n                    \"Error occurred during read: \", exc_info=True\n                )\n                raise IOError(e.args[0])\n            if log:\n                self.transaction_logger.debug(f\"Read returned {ret}\")\n        else:\n            if log:\n                self.transaction_logger.debug(\n                    f\"Reading {count} Bytes \" f\"from addr = {address}\"\n                )\n            try:\n                read = i2c_msg.read(address, count)\n>               self.bus.i2c_rdwr(read)\n\n../econ_tools/swamp/hexactrl_io.py:125: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2b2850>, i2c_msgs = (i2c_msg(32,1,b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff8a268dc0>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError\n\nDuring handling of the above exception, another exception occurred:\n\ni2c_ECONT = <econ_i2c.ECON_I2C object at 0xffff8a2b2a90>, CfgConverterT = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8a267280>\nsupport_ECONT = <utils.support.Support object at 0xffff8a2c0a90>, out_of_reset = None\n\n    @pytest.mark.ECONT\n    def test_wrong_reg_address_T(\n        i2c_ECONT, CfgConverterT, support_ECONT, out_of_reset,\n    ):\n        \"\"\"\n        Check that we get zeros when reading from some internal address that\n        doesn't correspond to any I2C register.\n        \"\"\"\n        i2c_ECONT.target.transport.write(\n            address=i2c_ECONT.target.base_address,\n            data=None,\n            internal_address=(0xFFFF - 16).to_bytes(2, \"big\"),\n        )\n    \n>       read_bytes = i2c_ECONT.target.transport.read(\n            address=i2c_ECONT.target.base_address,\n            count=16,\n        )\n\ntest_i2c.py:215: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <econ_tools.swamp.hexactrl_io.Xil_i2c object at 0xffff8a2b2a30>, address = 32, count = 16, log = True\n\n    def read(\n        self,\n        address: int,\n        count: int = 1,\n        log: bool = True,\n    ):\n        \"\"\"\n        Read data from the i2c address specified\n    \n        :param address: The address of the peripheral on the bus to read data\n            from, must be 0-127\n        :type address: byte\n        :param count: The number of bytes to read form the bus if the count is\n            larger than one a block read is performed. Defaults to 1.\n        :type count: int, optional\n        :return: Array of values read for the different bytes as list of ints\n        :rtype: list\n        \"\"\"\n        if count == 1:\n            if log:\n                self.transaction_logger.debug(\n                    f\"Reading SingleByte \" f\"from addr = {address}\"\n                )\n            try:\n                ret = self.bus.read_byte(address).to_bytes(1, \"little\")\n            except IOError as e:\n                self.transaction_logger.error(\n                    \"Error occurred during read: \", exc_info=True\n                )\n                raise IOError(e.args[0])\n            if log:\n                self.transaction_logger.debug(f\"Read returned {ret}\")\n        else:\n            if log:\n                self.transaction_logger.debug(\n                    f\"Reading {count} Bytes \" f\"from addr = {address}\"\n                )\n            try:\n                read = i2c_msg.read(address, count)\n                self.bus.i2c_rdwr(read)\n                ret = bytearray(list(read))\n            except IOError as e:\n                self.transaction_logger.error(\n                    \"Error occurred during read: \", exc_info=True\n                )\n>               raise IOError(e.args[0])\nE               OSError: 5\n\n../econ_tools/swamp/hexactrl_io.py:131: OSError"
      },
      "teardown": {
        "duration": 0.0013935610004409682,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_wrong_i2c_address_D",
      "lineno": 224,
      "outcome": "passed",
      "keywords": [
        "test_wrong_i2c_address_D",
        "pytestmark",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.003329234001284931,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0026387990001239814,
        "outcome": "passed",
        "log": [
          {
            "name": "Xil_i2c_bus_2",
            "msg": "Error occurred during read: ",
            "args": null,
            "levelname": "ERROR",
            "levelno": 40,
            "pathname": "/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py",
            "filename": "hexactrl_io.py",
            "module": "hexactrl_io",
            "exc_info": null,
            "exc_text": "Traceback (most recent call last):\n  File \"/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py\", line 125, in read\n    self.bus.i2c_rdwr(read)\n  File \"/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py\", line 658, in i2c_rdwr\n    ioctl(self.fd, I2C_RDWR, ioctl_data)\nOSError: [Errno 5] Input/output error",
            "stack_info": null,
            "lineno": 128,
            "funcName": "read",
            "created": 1722029014.8760295,
            "msecs": 876.0294914245605,
            "relativeCreated": 8431.772947311401,
            "thread": 281473294524448,
            "threadName": "MainThread",
            "processName": "MainProcess",
            "process": 3843
          }
        ]
      },
      "teardown": {
        "duration": 0.0012064470029145014,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_wrong_i2c_address_T",
      "lineno": 237,
      "outcome": "passed",
      "keywords": [
        "test_wrong_i2c_address_T",
        "pytestmark",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.0033670049997454043,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0024107939971145242,
        "outcome": "passed",
        "log": [
          {
            "name": "Xil_i2c_bus_2",
            "msg": "Error occurred during read: ",
            "args": null,
            "levelname": "ERROR",
            "levelno": 40,
            "pathname": "/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py",
            "filename": "hexactrl_io.py",
            "module": "hexactrl_io",
            "exc_info": null,
            "exc_text": "Traceback (most recent call last):\n  File \"/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py\", line 125, in read\n    self.bus.i2c_rdwr(read)\n  File \"/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py\", line 658, in i2c_rdwr\n    ioctl(self.fd, I2C_RDWR, ioctl_data)\nOSError: [Errno 5] Input/output error",
            "stack_info": null,
            "lineno": 128,
            "funcName": "read",
            "created": 1722029014.8869123,
            "msecs": 886.9123458862305,
            "relativeCreated": 8442.655801773071,
            "thread": 281473294524448,
            "threadName": "MainThread",
            "processName": "MainProcess",
            "process": 3843
          }
        ]
      },
      "teardown": {
        "duration": 0.0012153570023656357,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_hold_hard_reset_D",
      "lineno": 250,
      "outcome": "passed",
      "keywords": [
        "test_hold_hard_reset_D",
        "pytestmark",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.002071486997010652,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0027032099969801493,
        "outcome": "passed",
        "log": [
          {
            "name": "Xil_i2c_bus_2",
            "msg": "Error occurred during read: ",
            "args": null,
            "levelname": "ERROR",
            "levelno": 40,
            "pathname": "/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py",
            "filename": "hexactrl_io.py",
            "module": "hexactrl_io",
            "exc_info": null,
            "exc_text": "Traceback (most recent call last):\n  File \"/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py\", line 125, in read\n    self.bus.i2c_rdwr(read)\n  File \"/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py\", line 658, in i2c_rdwr\n    ioctl(self.fd, I2C_RDWR, ioctl_data)\nOSError: [Errno 5] Input/output error",
            "stack_info": null,
            "lineno": 128,
            "funcName": "read",
            "created": 1722029014.8964565,
            "msecs": 896.4564800262451,
            "relativeCreated": 8452.199935913086,
            "thread": 281473294524448,
            "threadName": "MainThread",
            "processName": "MainProcess",
            "process": 3843
          }
        ]
      },
      "teardown": {
        "duration": 0.0010667640017345548,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_hold_hard_reset_T",
      "lineno": 264,
      "outcome": "passed",
      "keywords": [
        "test_hold_hard_reset_T",
        "pytestmark",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.0021169370011193678,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.002750372001173673,
        "outcome": "passed",
        "log": [
          {
            "name": "Xil_i2c_bus_2",
            "msg": "Error occurred during read: ",
            "args": null,
            "levelname": "ERROR",
            "levelno": 40,
            "pathname": "/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py",
            "filename": "hexactrl_io.py",
            "module": "hexactrl_io",
            "exc_info": null,
            "exc_text": "Traceback (most recent call last):\n  File \"/home/jsw/mezz/econd-sw/test_mezzanine/../econ_tools/swamp/hexactrl_io.py\", line 125, in read\n    self.bus.i2c_rdwr(read)\n  File \"/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py\", line 658, in i2c_rdwr\n    ioctl(self.fd, I2C_RDWR, ioctl_data)\nOSError: [Errno 5] Input/output error",
            "stack_info": null,
            "lineno": 128,
            "funcName": "read",
            "created": 1722029014.9059772,
            "msecs": 905.9772491455078,
            "relativeCreated": 8461.720705032349,
            "thread": 281473294524448,
            "threadName": "MainThread",
            "processName": "MainProcess",
            "process": 3843
          }
        ]
      },
      "teardown": {
        "duration": 0.001094064999051625,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_hold_soft_reset_D",
      "lineno": 278,
      "outcome": "failed",
      "keywords": [
        "test_hold_soft_reset_D",
        "pytestmark",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.003392446000361815,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0020648569989134558,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 287,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 279.\nFailed on attempt 1 at write 0 of 279.\nFailed on attempt 2 at write 0 of 279.\n",
        "longrepr": "support_ECOND = <utils.support.Support object at 0xffff8a2c09a0>, i2c_ECOND = <econ_i2c.ECON_I2C object at 0xffff8a2c06a0>\nCfgConverterD = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8b328d30>, out_of_reset = None\n\n    @pytest.mark.ECOND\n    def test_hold_soft_reset_D(\n        support_ECOND, i2c_ECOND, CfgConverterD, out_of_reset,\n    ):\n        \"\"\"\n        Check that holding the ECON-D in soft reset does not affect I2C\n        communications nor the values in I2C registers.\n        \"\"\"\n>       i2c_ECOND.write_all(\n            CfgConverterD.RW_mask_array & (~CfgConverterD.default_value_array)\n        )\n\ntest_i2c.py:287: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2c0760>, i2c_msgs = (i2c_msg(96,0,b'\\x00\\x00~\\xff\\xff?\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff8a23b0c0>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0013898110009904485,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_hold_soft_reset_T",
      "lineno": 299,
      "outcome": "failed",
      "keywords": [
        "test_hold_soft_reset_T",
        "pytestmark",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.0033550640000612475,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.0021558779990300536,
        "outcome": "failed",
        "crash": {
          "path": "/home/jsw/.local/lib/python3.9/site-packages/smbus2/smbus2.py",
          "lineno": 658,
          "message": "OSError: [Errno 5] Input/output error"
        },
        "traceback": [
          {
            "path": "test_i2c.py",
            "lineno": 308,
            "message": ""
          },
          {
            "path": "../econ_i2c.py",
            "lineno": 136,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/ECON.py",
            "lineno": 109,
            "message": "in write_all"
          },
          {
            "path": "../econ_tools/swamp/hexactrl_io.py",
            "lineno": 51,
            "message": "in write"
          },
          {
            "path": "../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py",
            "lineno": 658,
            "message": "OSError"
          }
        ],
        "stdout": "Failed on attempt 0 at write 0 of 228.\nFailed on attempt 1 at write 0 of 228.\nFailed on attempt 2 at write 0 of 228.\n",
        "longrepr": "support_ECONT = <utils.support.Support object at 0xffff8a2c0a90>, i2c_ECONT = <econ_i2c.ECON_I2C object at 0xffff8a2b2a90>\nCfgConverterT = <econ_tools.swamp.cfgconverter.CfgConverter object at 0xffff8a267280>, out_of_reset = None\n\n    @pytest.mark.ECONT\n    def test_hold_soft_reset_T(\n        support_ECONT, i2c_ECONT, CfgConverterT, out_of_reset,\n    ):\n        \"\"\"\n        Check that holding the ECON-T in soft reset does not affect I2C\n        communications nor the values in I2C registers.\n        \"\"\"\n>       i2c_ECONT.write_all(\n            CfgConverterT.RW_mask_array & (~CfgConverterT.default_value_array)\n        )\n\ntest_i2c.py:308: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../econ_i2c.py:136: in write_all\n    self.target.write_all(self.cfg.array_to_bytes(data))\n../econ_tools/swamp/ECON.py:109: in write_all\n    self.transport.write(\n../econ_tools/swamp/hexactrl_io.py:51: in write\n    self.bus.i2c_rdwr(msg_send)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <smbus2.smbus2.SMBus object at 0xffff8a2b2850>, i2c_msgs = (i2c_msg(32,0,b'\\x00\\x00~\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'),)\nioctl_data = <smbus2.smbus2.i2c_rdwr_ioctl_data object at 0xffff8a2a81c0>\n\n    def i2c_rdwr(self, *i2c_msgs):\n        \"\"\"\n        Combine a series of i2c read and write operations in a single\n        transaction (with repeated start bits but no stop bits in between).\n    \n        This method takes i2c_msg instances as input, which must be created\n        first with :py:meth:`i2c_msg.read` or :py:meth:`i2c_msg.write`.\n    \n        :param i2c_msgs: One or more i2c_msg class instances.\n        :type i2c_msgs: i2c_msg\n        :rtype: None\n        \"\"\"\n        ioctl_data = i2c_rdwr_ioctl_data.create(*i2c_msgs)\n>       ioctl(self.fd, I2C_RDWR, ioctl_data)\nE       OSError: [Errno 5] Input/output error\n\n../../../.local/lib/python3.9/site-packages/smbus2/smbus2.py:658: OSError"
      },
      "teardown": {
        "duration": 0.0014048409975657705,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_chip_sync_D",
      "lineno": 320,
      "outcome": "passed",
      "keywords": [
        "test_chip_sync_D",
        "pytestmark",
        "ECOND",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.1783481890015537,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.15037214499898255,
        "outcome": "passed"
      },
      "teardown": {
        "duration": 0.0012721780003630556,
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test_i2c.py::test_chip_sync_T",
      "lineno": 341,
      "outcome": "passed",
      "keywords": [
        "test_chip_sync_T",
        "pytestmark",
        "ECONT",
        "test_i2c.py",
        "test_mezzanine"
      ],
      "setup": {
        "duration": 0.01514292800129624,
        "outcome": "passed"
      },
      "call": {
        "duration": 0.12348263500098255,
        "outcome": "passed"
      },
      "teardown": {
        "duration": 0.0012649790005525574,
        "outcome": "passed"
      }
    }
  ],
  "FPGA-hexa-IP": "11",
  "branch": "DN_CMtester_IO",
  "commit_hash": "4f4f43d62e25add927a484f024c3e2e08d3482d8",
  "remote_url": "ssh://git@gitlab.cern.ch:7999/hgcal-daq-sw/econd-sw.git",
  "status": "M common_pytest/fixtures.py\u0000 M gpib_controls\u0000 M test_mezzanine/conftest.py\u0000 M test_mezzanine/pytest.ini\u0000 M test_mezzanine/test_io.py\u0000 M utils/gpibclient.py\u0000?? econ_i2c.py.orig\u0000?? test_mezzanine/tmp.py\u0000?? test_radiation/conftest.py.orig\u0000?? test_vectors/\u0000?? utils/align.py.orig\u0000?? utils/io.py.orig\u0000",
  "firmware_name": "econ-mezz-tester-kria.bit\u0000",
  "firmware_git_desc": "9e5953f-dirty",
  "chip_number": null
}